% !TEX program = pdflatex
% !TEX spellcheck = en_US
\documentclass[aspectratio=169,svgnames,xcolor=table,t]{beamer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\lstset{basicstyle=\ttfamily,escapechar=\%,escapeinside={\#(}{\#)}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amstext}
\usepackage{calc}
\usepackage{tikz}
\usepackage{algorithm, algorithmic}
\usetikzlibrary{positioning}
\tikzset{place/.style={draw}}
\tikzset{>=stealth, auto, node distance=2.5cm, every loop/.style={->, min distance=10mm, in=0, out=60, looseness=10}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{uno_style.tex}
\input{macro.tex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Use enumitem and restore beamer defaults
% \usepackage{enumitem}
% \setitemize{label=\usebeamerfont*{itemize item}%
%   \usebeamercolor[fg]{itemize item}
%   \usebeamertemplate{itemize item}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\author[J. Fandinno \& Eleuterio Lillo Portero]{{\usebeamercolor[fg]{alerted text}Jorge Fandinno} and Eleuterio Lillo Portero}

\date{AAAI 2023}

\institute[UNO]{
    Department of Computer Science \\
    University of Nebraska Omaha
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document Metadata
\title{\texttt{eclingo} 2.0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\frame{\titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Solving Epistemic Logic Programs}
\begin{myitemize}
    \item \hi{\texttt{eclingo}} is a solver for epistemic logic programs.
    \begin{align*}
        \mathit{felon}   &\leftarrow \K\, \mathit{break\_rule}
        \\
        \mathit{suspect} &\leftarrow \neg \K\, \mathit{break\_rule}, \neg \K \neg \mathit{break\_rule}
    \end{align*}
    This encodes that a person a~$\mathit{felon}$ if we can determine that she broke a rule, and she is a~$\mathit{suspect}$ if it cannot be determined that she has broken nor that she has not done.

    \item Deciding if an epistemic logic program has an answer (called \hi{worldview}) is~$\Sigma^P_3$-complete and~$\Sigma^P_2$-complete for the case of dijuntive\nobreak-free programs.
    
    \item We developed a new version of \texttt{eclingo} that is \speedup{3.3x} faster and solves 87\% more instances.
\end{myitemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Solving Epistemic Logic Programs}
    \begin{myitemize}
        \item[] As the previous version, \texttt{eclingo} 2.0 uses a generate-and-test approach.
    \end{myitemize}
    \begin{algorithm}[H]
        \scriptsize
        \caption{Generate-and-test computation of~$n$ worldviews of a program~$\Pi$ in normal form.}\label{alg:guess-and-check}
        \hspace*{\algorithmicindent} \textbf{Input} Generate program $G(\Pi)$\\
        \hspace*{\algorithmicindent} \textbf{Input} Test program $T(\Pi)$\\
        \hspace*{\algorithmicindent} \textbf{Input} Number of requested worldviews~$n$\\
        \hspace*{\algorithmicindent} \textbf{Output} Set~$\Omega$ containing~$n$  worldviews of~$\Pi$
    
        \begin{algorithmic}[1] %[1] enables line numbers
            \STATE Let $\Omega=\emptyset$.
            \FOR{$M$ in $\SM{G(\Pi)}$} \label{alg.generator.loop.ini}
                \IF {\texttt{Test$(T(\Pi),\,M)$}}
                \STATE $\wv$ = \texttt{BuildWorldView$(M)$}
                \STATE $\Omega$ = $\Omega \cup \{ \wv \}$
                    \IF {$|\Omega| \geq n$}
                    \STATE \textbf{return} $\Omega$
                    \ENDIF
                \ENDIF
            \ENDFOR \label{alg.generator.loop.end}
            \STATE \textbf{return} $\Omega$
        \end{algorithmic}
    \end{algorithm}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Solving Epistemic Logic Programs}
    \begin{myitemize}
        \item We first compute a normal form of the program in which negation is not in the scope of the epistemic operator.
        \begin{itemize}
            \item The testing if a candidate corresponds to a worldview can be done by computing the cautions consequences (without normal form the brave consequences are also necessary).
        \end{itemize}
        
        \item In the paper, we describe sufficient conditions for the generate and test program for this algorithm to be correct.
        
        \item The main idea of the new solver is to use a new generator program that produces fewer candidates.
    \end{myitemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Basic Generate Program}
    \begin{myitemize}
        \item Replaces epistemic atoms~$\K\,a$ by a fresth atom~$\kk{a}$ and introduces a choice rule fore each fresh atom.
    \end{myitemize}
    For the epistemic program, 
    \begin{align*}
        b &\leftarrow \K a
    \end{align*}
    we get the generate program
    \begin{align*}
        b &\leftarrow ka
        &\hspace{10pt}
        \{ ka \} &\leftarrow a
    \end{align*}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Propagate Epistemic Consequences}
    \begin{myitemize}
        \item[] The key idea is to propagate the consequences of epistemic decisions.
    \end{myitemize}
    For the epistemic program, 
    \begin{align*}
        a &&
        b &\leftarrow \K a
        &
        c &\leftarrow \K b
    \end{align*}
    Note that~$\K a$ is true because~$a$ is a fact.
    %
    Furthemore, whenever we have~$\K a$, we have~$b$ \hi{but also~$\K b$}.
    
    \pause

    The generate program becomes
    \begin{align*}
        a && 
        \\
        b &\leftarrow ka
        &\hspace{10pt}
        \{ ka \} &\leftarrow a
        \\
        c &\leftarrow kb
        &\hspace{10pt}
        \{ kb \} &\leftarrow b
        \\
        \hi{\kp{a}}&
        &
        &\hi{\leftarrow \kp{a} \wedge \neg ka}
        \\
        \hi{\kp{b}} &\hi{\leftarrow ka}
        &
        &\hi{\leftarrow \kp{b} \wedge \neg kb}
    \end{align*}

    \hi{$\kp{b}$} is used to distinguish that~$\K b$ is a consequence dervided from choices of epistemic atoms while~$kb$ only states that~$\K b$ has been chosen to be true.
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Propagate Epistemic Consequences}
    \begin{myitemize}
        \item[] For every normal rule of the form
        \begin{align}
            a_1 &\leftarrow 
            a_2,\!\dotsc\!,a_k,
            \neg a_{k+1},\!\dotsc\!,\neg a_m,
            {L_{m+1}},\!\dotsc\!,{L_n}
        \end{align}
        with each~$L_i$ a~$\K$-atom, we add a rule of the form
        \begin{gather}
            \begin{aligned}
                \kp{a_1} &\span\span\leftarrow 
                \kp{a_2},\dotsc,\kp{a_k},
                \kpnott{a_{k+1}},\dotsc,\kpnott{a_m},
                \kk{L_{m+1}},\dotsc,\kk{L_n}
            \end{aligned}
        \end{gather}
        \vspace*{-15pt}
        \begin{itemize}
            \item \kp{a} means that we have concluded that~$a$ is true in all stable models corresponding to the considered candidate worldview.
            \item \kpnott{a} means that we have concluded that~$a$ is false in all stable models corresponding to the considered candidate worldview.
            \item atoms of the form~\kpnott{a} are derived through a kind of completion of the program.
        \end{itemize}
    \end{myitemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[c]{Propagate Epistemic Consequences}
    \begin{theorem}
        This method produces a valid generator program, and, thus, Algorithm~\ref{alg:guess-and-check} correctly computes the worldviews.
        %
        Furthermore,
        \begin{itemize}
            \item It produces at most as many candidates as the basic generator program.
            \item For some program class, it produces exponentially fewer candidates.
            \item It only introduces a linear overhead.
        \end{itemize}
    \end{theorem}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Implementation}
    \begin{myitemize}
        \item Our implementation is built on top of version~5.7 of the ASP solver~\texttt{clingo} using Python and ASP.
        \begin{itemize}
            \item We use reification and metaprogramming to describe the generate and test programs.
            \item We can change the generate and test programs by changing an ASP program.
        \end{itemize}
    \end{myitemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Experimental Results}
    \begin{myitemize}
        \item We compare our new solver with We also compare our implementation with~\texttt{EP-ASP},
        the previous version of~\texttt{eclingo},
        \texttt{selp}, and~\texttt{elp2qasp}.
    \end{myitemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame{\backcoverpage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}